<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AccelByte Online Subsystem: FOnlineUserCacheAccelByte Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AccelByte Online Subsystem<span id="projectnumber">&#160;0.12.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d8/dfc/class_f_online_user_cache_accel_byte.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="../../d0/d23/class_f_online_user_cache_accel_byte-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">FOnlineUserCacheAccelByte Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d7/d3c/_online_user_cache_accel_byte_8h_source.html">OnlineUserCacheAccelByte.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5593b4e8f8bb3c624798baea96917c43" id="r_a5593b4e8f8bb3c624798baea96917c43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a5593b4e8f8bb3c624798baea96917c43">QueryUsersByAccelByteIds</a> (int32 LocalUserNum, const TArray&lt; FString &gt; &amp;AccelByteIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="separator:a5593b4e8f8bb3c624798baea96917c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd71113b3721a68d844ce804ff75c2d" id="r_a3bd71113b3721a68d844ce804ff75c2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a3bd71113b3721a68d844ce804ff75c2d">QueryUsersByPlatformIds</a> (int32 LocalUserNum, const FString &amp;PlatformType, const TArray&lt; FString &gt; &amp;PlatformIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="separator:a3bd71113b3721a68d844ce804ff75c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e29cec3606130813f5fa2a0b4d4d8a8" id="r_a2e29cec3606130813f5fa2a0b4d4d8a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a2e29cec3606130813f5fa2a0b4d4d8a8">QueryUsersByAccelByteIds</a> (const FUniqueNetId &amp;UserId, const TArray&lt; FString &gt; &amp;AccelByteIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="separator:a2e29cec3606130813f5fa2a0b4d4d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915c35c637d81aa08ac598ee742e1f2f" id="r_a915c35c637d81aa08ac598ee742e1f2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a915c35c637d81aa08ac598ee742e1f2f">QueryUsersByPlatformIds</a> (const FUniqueNetId &amp;UserId, const FString &amp;PlatformType, const TArray&lt; FString &gt; &amp;PlatformIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="separator:a915c35c637d81aa08ac598ee742e1f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405dd4fcfe853ebcf82771e8a96168e" id="r_a2405dd4fcfe853ebcf82771e8a96168e"><td class="memItemLeft" align="right" valign="top">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a2405dd4fcfe853ebcf82771e8a96168e">GetUser</a> (const FUniqueNetId &amp;UserId)</td></tr>
<tr class="separator:a2405dd4fcfe853ebcf82771e8a96168e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f58ba07f8eac04a16372027cd225c2" id="r_a31f58ba07f8eac04a16372027cd225c2"><td class="memItemLeft" align="right" valign="top">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a31f58ba07f8eac04a16372027cd225c2">GetUser</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;UserId)</td></tr>
<tr class="separator:a31f58ba07f8eac04a16372027cd225c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad063290c194ca3a632920f853f1da08a" id="r_ad063290c194ca3a632920f853f1da08a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#ad063290c194ca3a632920f853f1da08a">AddUsersToCache</a> (const TArray&lt; TSharedRef&lt; <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt; &gt; &amp;UsersQueried)</td></tr>
<tr class="separator:ad063290c194ca3a632920f853f1da08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1052a31b19d3b3dce0449465e6961373" id="r_a1052a31b19d3b3dce0449465e6961373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a1052a31b19d3b3dce0449465e6961373">AddPublicCodeToCache</a> (const FUniqueNetId &amp;UserId, const FString &amp;PublicCode)</td></tr>
<tr class="separator:a1052a31b19d3b3dce0449465e6961373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0e38983edeb236c378c7bfd75b9f34" id="r_ade0e38983edeb236c378c7bfd75b9f34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#ade0e38983edeb236c378c7bfd75b9f34">AddPublicCodeToCache</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;UserId, const FString &amp;PublicCode)</td></tr>
<tr class="separator:ade0e38983edeb236c378c7bfd75b9f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f60090e69b111745f64edd5a8975de" id="r_a67f60090e69b111745f64edd5a8975de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a67f60090e69b111745f64edd5a8975de">AddLinkedPlatformInfoToCache</a> (const FUniqueNetId &amp;UserId, const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;LinkedPlatformInfo)</td></tr>
<tr class="separator:a67f60090e69b111745f64edd5a8975de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08efee8465fba7ab2d9f598bad7a425c" id="r_a08efee8465fba7ab2d9f598bad7a425c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a08efee8465fba7ab2d9f598bad7a425c">AddLinkedPlatformInfoToCache</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;UserId, const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;LinkedPlatformInfo)</td></tr>
<tr class="separator:a08efee8465fba7ab2d9f598bad7a425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee022bd598d74e93eacf3bc42144633" id="r_aeee022bd598d74e93eacf3bc42144633"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#aeee022bd598d74e93eacf3bc42144633">Purge</a> ()</td></tr>
<tr class="separator:aeee022bd598d74e93eacf3bc42144633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a955336561270b29e20de0268a2cbbd" id="r_a3a955336561270b29e20de0268a2cbbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a3a955336561270b29e20de0268a2cbbd">IsUserCached</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;Id)</td></tr>
<tr class="separator:a3a955336561270b29e20de0268a2cbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa9d68272369cabc339849bf6359244" id="r_adfa9d68272369cabc339849bf6359244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#adfa9d68272369cabc339849bf6359244">GetQueryAndCacheArrays</a> (const TArray&lt; FString &gt; &amp;AccelByteIds, TArray&lt; FString &gt; &amp;UsersToQuery, TArray&lt; TSharedRef&lt; <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt; &gt; &amp;UsersInCache)</td></tr>
<tr class="separator:adfa9d68272369cabc339849bf6359244"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e0af2f8ad9b0a5a8a005da4e8df6936" id="r_a5e0af2f8ad9b0a5a8a005da4e8df6936"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a5e0af2f8ad9b0a5a8a005da4e8df6936">GetFromSubsystem</a> (const IOnlineSubsystem *Subsystem, TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;OutInterfaceInstance)</td></tr>
<tr class="separator:a5e0af2f8ad9b0a5a8a005da4e8df6936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae27b7bc217f688d08fe4ee1839564" id="r_a18ae27b7bc217f688d08fe4ee1839564"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html#a18ae27b7bc217f688d08fe4ee1839564">GetFromWorld</a> (const UWorld *World, TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;OutInterfaceInstance)</td></tr>
<tr class="separator:a18ae27b7bc217f688d08fe4ee1839564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae293ab1f02f36034a6f65f77eaf2ba4e" id="r_ae293ab1f02f36034a6f65f77eaf2ba4e"><td class="memItemLeft" align="right" valign="top"><a id="ae293ab1f02f36034a6f65f77eaf2ba4e" name="ae293ab1f02f36034a6f65f77eaf2ba4e"></a>
PACKAGE_SCOPE&#160;</td><td class="memItemRight" valign="bottom">: <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>(<a class="el" href="../../d5/d5d/class_f_online_subsystem_accel_byte.html">FOnlineSubsystemAccelByte</a>* InSubsystem)</td></tr>
<tr class="separator:ae293ab1f02f36034a6f65f77eaf2ba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages users that are queried from the AccelByte backend, making bulk calls to retrieve user data, as well as getting extra necessary information for those users, such as platform IDs relevant to the current native platform.</p>
<p>As an explanation of how this works under the hood, the cache is made of shared <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html" title="Plain data structure representing an AccelByte user that is cached locally.">FAccelByteUserInfo</a> instances that are put into two maps. One map is for mapping the AccelByte ID to the user's information, and one is for mapping platform information to the user's information. This way either can be queried seamlessly to get the same user data. The only time you won't be able to query a user by their platform IDs is if they are not on the same platform as you, in which you can only query by AccelByte ID.</p>
<p>User data will be kept cached based on how long it has been since they have been accessed. You can configure how long users will stay in cache with the <code>UserCachePurgeTimeoutSeconds</code> variable in the <code>OnlineSubsystemAccelByte</code> settings in <code>DefaultEngine.ini</code>. Users will also not be purged if they were marked as important when queried. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a08efee8465fba7ab2d9f598bad7a425c" name="a08efee8465fba7ab2d9f598bad7a425c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08efee8465fba7ab2d9f598bad7a425c">&#9670;&#160;</a></span>AddLinkedPlatformInfoToCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddLinkedPlatformInfoToCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;&#160;</td>
          <td class="paramname"><em>UserId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>LinkedPlatformInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linked platform information to the user cache for a given composite user ID. Creates a new cache entry if the user does not already exist in the cache. </p>

</div>
</div>
<a id="a67f60090e69b111745f64edd5a8975de" name="a67f60090e69b111745f64edd5a8975de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f60090e69b111745f64edd5a8975de">&#9670;&#160;</a></span>AddLinkedPlatformInfoToCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddLinkedPlatformInfoToCache </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;&#160;</td>
          <td class="paramname"><em>UserId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>LinkedPlatformInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linked platform information to the user cache for a given user ID. Creates a new cache entry if the user does not already exist in the cache. </p>

</div>
</div>
<a id="ade0e38983edeb236c378c7bfd75b9f34" name="ade0e38983edeb236c378c7bfd75b9f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0e38983edeb236c378c7bfd75b9f34">&#9670;&#160;</a></span>AddPublicCodeToCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddPublicCodeToCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;&#160;</td>
          <td class="paramname"><em>UserId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>PublicCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add PublicCode to a user cache, create new if not exist </p>

</div>
</div>
<a id="a1052a31b19d3b3dce0449465e6961373" name="a1052a31b19d3b3dce0449465e6961373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1052a31b19d3b3dce0449465e6961373">&#9670;&#160;</a></span>AddPublicCodeToCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddPublicCodeToCache </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;&#160;</td>
          <td class="paramname"><em>UserId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>PublicCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add PublicCode to a user cache, create new if not exist </p>

</div>
</div>
<a id="ad063290c194ca3a632920f853f1da08a" name="ad063290c194ca3a632920f853f1da08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad063290c194ca3a632920f853f1da08a">&#9670;&#160;</a></span>AddUsersToCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddUsersToCache </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; TSharedRef&lt; <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>UsersQueried</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of freshly queried users to the user cache </p>

</div>
</div>
<a id="a5e0af2f8ad9b0a5a8a005da4e8df6936" name="a5e0af2f8ad9b0a5a8a005da4e8df6936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0af2f8ad9b0a5a8a005da4e8df6936">&#9670;&#160;</a></span>GetFromSubsystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::GetFromSubsystem </td>
          <td>(</td>
          <td class="paramtype">const IOnlineSubsystem *&#160;</td>
          <td class="paramname"><em>Subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;&#160;</td>
          <td class="paramname"><em>OutInterfaceInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience method to get an instance of this interface from the subsystem passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Subsystem</td><td>Subsystem instance that we wish to get this interface from </td></tr>
    <tr><td class="paramname">OutInterfaceInstance</td><td>Instance of the interface that we got from the subsystem, or nullptr if not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean that is true if we could get an instance of the interface, false otherwise </dd></dl>

</div>
</div>
<a id="a18ae27b7bc217f688d08fe4ee1839564" name="a18ae27b7bc217f688d08fe4ee1839564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae27b7bc217f688d08fe4ee1839564">&#9670;&#160;</a></span>GetFromWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::GetFromWorld </td>
          <td>(</td>
          <td class="paramtype">const UWorld *&#160;</td>
          <td class="paramname"><em>World</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;&#160;</td>
          <td class="paramname"><em>OutInterfaceInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience method to get an instance of this interface from the subsystem associated with the world passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">World</td><td>World instance that we wish to get the interface from </td></tr>
    <tr><td class="paramname">OutInterfaceInstance</td><td>Instance of the interface that we got from the subsystem, or nullptr if not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean that is true if we could get an instance of the interface, false otherwise </dd></dl>

</div>
</div>
<a id="adfa9d68272369cabc339849bf6359244" name="adfa9d68272369cabc339849bf6359244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa9d68272369cabc339849bf6359244">&#9670;&#160;</a></span>GetQueryAndCacheArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::GetQueryAndCacheArrays </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>AccelByteIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>UsersToQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; TSharedRef&lt; <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>UsersInCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method used by user queries to get an array of users that we still need to query, as well as shared instances to users that we have already queried and can retrieve from the cache </p>

</div>
</div>
<a id="a31f58ba07f8eac04a16372027cd225c2" name="a31f58ba07f8eac04a16372027cd225c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f58ba07f8eac04a16372027cd225c2">&#9670;&#160;</a></span>GetUser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt; FOnlineUserCacheAccelByte::GetUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;&#160;</td>
          <td class="paramname"><em>UserId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to get a user from the cache by a composite ID structure. </p>

</div>
</div>
<a id="a2405dd4fcfe853ebcf82771e8a96168e" name="a2405dd4fcfe853ebcf82771e8a96168e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405dd4fcfe853ebcf82771e8a96168e">&#9670;&#160;</a></span>GetUser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a> &gt; FOnlineUserCacheAccelByte::GetUser </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;&#160;</td>
          <td class="paramname"><em>UserId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to get a user from the cache by an AccelByte unique ID. This ID comes from either an <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html#a9f35ed0fc405d0a9a5f32feee5915641" title="Composite ID representation for this user, platform information may be blank if we cannot retrieve th...">FAccelByteUserInfo::Id</a> field, or from the result of a query users call. </p>

</div>
</div>
<a id="a3a955336561270b29e20de0268a2cbbd" name="a3a955336561270b29e20de0268a2cbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a955336561270b29e20de0268a2cbbd">&#9670;&#160;</a></span>IsUserCached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::IsUserCached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;&#160;</td>
          <td class="paramname"><em>Id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a user exists already in the cache so that we don't requery them. </p>

</div>
</div>
<a id="aeee022bd598d74e93eacf3bc42144633" name="aeee022bd598d74e93eacf3bc42144633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee022bd598d74e93eacf3bc42144633">&#9670;&#160;</a></span>Purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 FOnlineUserCacheAccelByte::Purge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches through the user caches for a user that hasn't been accessed in longer than the maximum time set for this cache. If a user is found that exceeds this max time, and they are not marked as important, they will be removed from the cache entirely.</p>
<p>Will return the number of users purged from the cache.</p>
<p>Do not call this method directly, it will be called from the owning OnlineSubsystem's ticker! </p>

</div>
</div>
<a id="a2e29cec3606130813f5fa2a0b4d4d8a8" name="a2e29cec3606130813f5fa2a0b4d4d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e29cec3606130813f5fa2a0b4d4d8a8">&#9670;&#160;</a></span>QueryUsersByAccelByteIds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByAccelByteIds </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;&#160;</td>
          <td class="paramname"><em>UserId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>AccelByteIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;&#160;</td>
          <td class="paramname"><em>Delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsImportant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries all of the IDs listed in the array on the AccelByte backend for user information, including platform IDs. If platform IDs are found and match the current platform that we are on, extra queries will be made through the platform OSSes.</p>
<p>Caches any results that we get from the backend, as well as will not query from the backend again if a duplicate is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>FUniqueNetId of the user that is attempting to query for users </td></tr>
    <tr><td class="paramname">AccelByteIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5593b4e8f8bb3c624798baea96917c43" name="a5593b4e8f8bb3c624798baea96917c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5593b4e8f8bb3c624798baea96917c43">&#9670;&#160;</a></span>QueryUsersByAccelByteIds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByAccelByteIds </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>LocalUserNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>AccelByteIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;&#160;</td>
          <td class="paramname"><em>Delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsImportant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries all of the IDs listed in the array on the AccelByte backend for user information, including platform IDs. If platform IDs are found and match the current platform that we are on, extra queries will be made through the platform OSSes.</p>
<p>Caches any results that we get from the backend, as well as will not query from the backend again if a duplicate is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LocalUserNum</td><td>Index of the user that is attempting to query for other users </td></tr>
    <tr><td class="paramname">AccelByteIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a915c35c637d81aa08ac598ee742e1f2f" name="a915c35c637d81aa08ac598ee742e1f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915c35c637d81aa08ac598ee742e1f2f">&#9670;&#160;</a></span>QueryUsersByPlatformIds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByPlatformIds </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;&#160;</td>
          <td class="paramname"><em>UserId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>PlatformType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>PlatformIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;&#160;</td>
          <td class="paramname"><em>Delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsImportant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to query all platform IDs listed for the particular platform specified on the AccelByte backend to find AccelByte user matches. If a matches are found, a subsequent query and cache will be performed to get information from the AccelByte backend on those users.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>FUniqueNetId of the user that is attempting to query for users </td></tr>
    <tr><td class="paramname">PlatformType</td><td>String representing the type of platform that these IDs belong to </td></tr>
    <tr><td class="paramname">PlatformIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bd71113b3721a68d844ce804ff75c2d" name="a3bd71113b3721a68d844ce804ff75c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd71113b3721a68d844ce804ff75c2d">&#9670;&#160;</a></span>QueryUsersByPlatformIds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByPlatformIds </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>LocalUserNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>PlatformType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>PlatformIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;&#160;</td>
          <td class="paramname"><em>Delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsImportant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to query all platform IDs listed for the particular platform specified on the AccelByte backend to find AccelByte user matches. If a matches are found, a subsequent query and cache will be performed to get information from the AccelByte backend on those users.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LocalUserNum</td><td>Index of the user that is attempting to query for other users </td></tr>
    <tr><td class="paramname">PlatformType</td><td>String representing the type of platform that these IDs belong to </td></tr>
    <tr><td class="paramname">PlatformIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/JusticeSDK/justice-ue4-oss-sample/Plugins/AccelByte/OnlineSubsystemAccelByte/Source/OnlineSubsystemAccelByte/Public/<a class="el" href="../../d7/d3c/_online_user_cache_accel_byte_8h_source.html">OnlineUserCacheAccelByte.h</a></li>
<li>D:/JusticeSDK/justice-ue4-oss-sample/Plugins/AccelByte/OnlineSubsystemAccelByte/Source/OnlineSubsystemAccelByte/Private/<b>OnlineUserCacheAccelByte.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
